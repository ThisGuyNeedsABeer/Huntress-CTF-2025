# reconstruct_decrypt.py
from binascii import hexlify

# immediates in the order they are pushed (appearance order in the asm)
pushes = [
    0x8484D893,
    0x97C6C390,
    0x929390C3,
    0xC7C3C490,
    0x939C939C,
    0xC6C69CC0,
    0x939CC697,
    0xC19DC794,
    0x9196C1DE,
    0xC2C4C9C3,
]

# Memory layout at ESP after all pushes: last push is at lowest address first.
# So construct bytes by iterating pushes in reverse order and taking little-endian bytes.
data = b''.join((x.to_bytes(4, 'little') for x in reversed(pushes)))  # 40 bytes

# The routine XORs each dword with 0xA5A5A5A5
key = 0xA5A5A5A5
dec = bytearray()
for i in range(0, len(data), 4):
    dword = int.from_bytes(data[i:i+4], 'little')
    dec_dword = dword ^ key
    dec += dec_dword.to_bytes(4, 'little')

print("raw decrypted hex:", hexlify(dec).decode())
print("raw decrypted bytes:", dec)
# The routine then copies the first 0x26 (38) bytes into a buffer and null-terminates
s = dec[:0x26]
print("\nfirst 0x26 bytes (hex):", hexlify(s).decode())
try:
    print("as ascii (printable or . for nonprint):")
    print(''.join((chr(b) if 32 <= b < 127 else '.') for b in s))
except:
    print(s)