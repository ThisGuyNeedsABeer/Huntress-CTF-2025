#!/usr/bin/env python3
"""
tele.py
Simple Telegram Bot API poller: prints messages the bot has received for a given chat id.

Usage:
  python tele.py -t <BOT_TOKEN> -c <CHAT_ID>
Or set env vars TELE_TOKEN and TELE_CHAT_ID.

Notes:
- Bots only see messages they receive (private messages to the bot, replies, or messages in groups where the bot is present).
- Treat your bot token like a password; rotate it if it was exposed.
"""

import os
import sys
import time
import argparse
import requests

DEFAULT_POLL_INTERVAL = 2
DEFAULT_TIMEOUT = 10

def get_args():
    p = argparse.ArgumentParser()
    p.add_argument("-t", "--token", help="Bot token (or set TELE_TOKEN env var)")
    p.add_argument("-c", "--chat", help="Chat id (or set TELE_CHAT_ID env var)")
    p.add_argument("--poll-interval", type=float, default=DEFAULT_POLL_INTERVAL, help="Seconds between polls")
    p.add_argument("--timeout", type=int, default=DEFAULT_TIMEOUT, help="getUpdates long-poll timeout")
    return p.parse_args()

def make_base(token):
    return f"https://api.telegram.org/bot{token}"

def get_chat_info(base, chat_id):
    r = requests.get(f"{base}/getChat", params={"chat_id": chat_id}, timeout=10)
    r.raise_for_status()
    j = r.json()
    if not j.get("ok"):
        raise RuntimeError(f"getChat failed: {j}")
    return j["result"]

def fetch_updates(base, offset=None, timeout=DEFAULT_TIMEOUT):
    params = {"timeout": timeout}
    if offset is not None:
        params["offset"] = offset
    r = requests.get(f"{base}/getUpdates", params=params, timeout=timeout + 5)
    r.raise_for_status()
    j = r.json()
    if not j.get("ok"):
        raise RuntimeError(f"getUpdates failed: {j}")
    return j["result"]

def filter_messages_for_chat(updates, chat_id):
    msgs = []
    for u in updates:
        for key in ("message", "edited_message", "channel_post", "edited_channel_post"):
            if key in u:
                m = u[key]
                chat = m.get("chat", {})
                if str(chat.get("id")) == str(chat_id):
                    msgs.append(m)
    return msgs

def pretty_print_message(m):
    mid = m.get("message_id")
    sender = "unknown"
    if "from" in m and m["from"] is not None:
        sender = m["from"].get("username") or m["from"].get("first_name") or m["from"].get("id")
    text = m.get("text") or m.get("caption") or "<non-text or empty>"
    ts = m.get("date")
    print(f"[{mid}] {sender} @ {ts}: {text}")

def main():
    args = get_args()
    token = args.token or os.getenv("TELE_TOKEN")
    chat_id = args.chat or os.getenv("TELE_CHAT_ID")

    if not token or not chat_id:
        print("Usage: python tele.py -t <TOKEN> -c <CHAT_ID>")
        print("Or set TELE_TOKEN and TELE_CHAT_ID environment variables.")
        sys.exit(1)

    base = make_base(token)

    try:
        info = get_chat_info(base, chat_id)
        title = info.get("title") or info.get("username") or info.get("first_name") or str(info.get("id"))
        print(f"Chat: {title} (id={chat_id})")
    except Exception as e:
        # don't exit â€” bot may still receive updates even if getChat fails (e.g., private chats)
        print("Warning: getChat failed:", e)

    offset = None
    print("Starting polling (Ctrl-C to stop)...")
    try:
        while True:
            updates = fetch_updates(base, offset=offset, timeout=args.timeout)
            if updates:
                # update offset so we don't re-read the same updates next time
                offset = max(u["update_id"] for u in updates) + 1
                msgs = filter_messages_for_chat(updates, chat_id)
                for m in msgs:
                    pretty_print_message(m)
            time.sleep(args.poll_interval)
    except KeyboardInterrupt:
        print("\nStopped by user.")
    except Exception as e:
        print("Error:", e)
        sys.exit(1)

if __name__ == "__main__":
    main()
